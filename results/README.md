# Program verification - Assignment 1
**Jakub Lichman** and **Kostas Triantafyllou**

## CNF Conversion

CNF conversion is implemented in two files: CNF.scala (tseitin part) and CNFConverter.scala (all other parts as static methods). We added two more tests for tseitin conversion - random and exhaustive one.

### Tseitin CNF conversion vs. Disjunction distribution

After implementation of tseitin CNF conversion and its usage for converting formulas into CNF format we have decided to use it for convertion of formula generated by Sudoku solver into CNF format. 
However, during implementation of sudoku it turned out that tseitin conversion is not efficient for this type of problem because it introduces many new variables. 
While in theory tseitin conversion does not introduce computing overhead, in reality it does.
Difficulty of formula in term of decisions is not increaded by tseitin because it introduces many variables which are tightly correlated. 
However this correlation causes meny consequent unit propagations which in case of wrong decision need to be undone. 
This step causes huge overhead that causes that formula is not solvable in reasonable time while in disjunction distribution case it takes no more than two seconds for easy and medium problems and up to 6 seconds for difficult ones. 

As a consequence we wanted to see performance of both techniques in terms of formula conversion and consequent performance of solvers over converted formula.
Following table shows average performance of these techniques in formula conversion.

| Conversion        | Dis. distribution   | Tseitin   |
| ----------------- |:-------------------:| ---------:|
| 100 Random tests  | 12.5532s            | 9.2112s   |
| 100 Exhaustive    | 3.2045s             | 2.4605s   |

We can see that tseitin conversion is faster but not suitable for sudoku solving. 

## SAT Algorithms
We have implemented the DPLL and CDCL algorithms as are described in the lectures. They are implemented in a way where we can reuse majority of DPLL code in CDCL. Therefore DPLL is base class of CDCL. Both solvers take multiple parameters so we can try different solving strategies.

Arguments of DPLL:
* usePureLiteralRule: Boolean
* useTseitinConversion : Boolean
* strategy: String

Strategy can be set to following values: {"first", "smallest", "random"} where "first" represents strategy where next decision literal is chosen from first not disabled clause and it becomes first undisabled literal in this clause. In "smallest" strategy literal is picked from currently smallest clause and in "random" choice is decision literal chosen randomly. Although this allowes us to create up to 12 different configurations, not all of them make sense. For instance useTseitinConversion argument makes no effect if given formula is already in cnf (it usually is). 

Therefore we have decided to compare DPLL with and without pure literal rule and all decision literal choosing strategies. For both DPLL and CDCL we have decided to split tests into two categories: random and structured ones. The results are as follows:

TODO: Add graphs and comment them.

In CDCL we introduced one more parameter which indicates whether we should use *clause learning* or not. With this additional parameter we can create 24 different configurations but again majority of them make no sense. For instance, we have learned from DPLL case that pure literal rule makes very small effect so we can omit it. 

As an result of that we have decided to compare CDCL with and without clause learning and all decision literal choosing strategies. Tests are also split into random and structured ones and results are as follows:

TODO: Add graphs and comment them.

## Sudoku

We also implemented bonus task - sudoku by encoding mechanism described in [paper](https://pdfs.semanticscholar.org/535d/06391275618a7b913d1c98a1353286db8d74.pdf) written by Inês Lynce and Jöel Ouaknine. They presented two approaches but we picked minimal encoding that looked more readable to us. All tests even the hardest ones are able to finish within 30 seconds with CDCLBaseline solver. We did not try other solvers since CDCL is clearly faster than DPLL on structured tests.

### Sudoku performance

After successful validation of our sudoku implementation we have decided to test the performance of selected solver configurations. It turned out that there is no clear winner. Formula is in every sudoku almost identical except the conjoined literals that are part of initial number distribution over grid. It is interesting to see that these small modifications caused different performances of solvers. We have picked few represenatives that represent patterns that repeat in results. Three most common patterns are where DPLL Baseline is much faster than the other solvers (sudoku 9 and 10), DPLL Baseline is much slower than the others (suduko 35 and 38) and pattern where all four solvers managed to solve the formula in more or less the same time. You can see all interesting results including those with the observed patterns in the next table:

| Sudoku test        | DPLL Baseline   | DPLL Without Pure  | CDCL Baseline | CDCL Without Learning  |
| ------------------ |:---------------:| ------------------:|:-------------:|:----------------------:|
| sudoku9.txt        | 3224.4s         | 5150.2s            | 6039.8s       | 5445.6s                |
| sudoku10.txt       | 2222.6s         | 2812.8s            | 2745.2s       | 2799.2s                |
| sudoku35.txt       | 1780.0s         | 1127.0s            | 1016.6s       | 1162.2s                |
| sudoku38.txt       | 1507.8s         | 1094.4s            | 1082.4s       | 1063.0s                |
| sudoku5.txt        | 1057.2s         | 1110.8s            | 1091.4s       | 1430.6s                |
| sudoku11.txt       | 1100.8s         | 2133.2s            | 1221.8s       | 1193.4s                |
| sudoku13.txt       | 1290.2s         | 1314.0s            | 1400.4s       | 1350.4s                |
| sudoku3.txt        | 1368.4s         | 1436.8s            | 1456.8s       | 1445.8s                |
| sudoku18.txt       | 1574.6s         | 1666.0s            | 1296.6s       | 1313.0s                |

We can see that pure literal rule in most cases actually slowes down solving but in two of them shown in table above it makes solving much faster. It these cases it is probable that pure literal rule is done in early stages of the algorithm and it avoids unnecessary decisions. However such a difference was unexpected from our side. Clause learning also does not help because just in sudoku5 case it made the algorithm faster. We think that it is caused by structure of the formula where same problem does not appear many times and so learned clauses make algorithm slower because they make formula bigger.

* *All tests were run 15 times and we dropped first 5 runs and took average of remaining 10.*
* *You can find all results of sudoku in [sudoku](sudoku) folder.*
* *All tests we run on MacBook Pro 2.7 GHz Intel Core i5, 8 GB 1867 MHz DDR3*
